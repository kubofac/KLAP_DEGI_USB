<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>KLAP_DEGI_USB - Log & Design Integrated</title>
    <style>
        :root { 
            --hrc-red: #E4002B; 
            --hrc-blue: #004098; 
            --hrc-white: #ffffff; 
            --bg-dark: #000000; 
            --hrc-orange: #FFA500;
        }

        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            background-color: var(--bg-dark); color: var(--hrc-white); 
            font-family: 'Arial Black', sans-serif; overflow: hidden; 
        }

        #dashboard { position: relative; display: flex; flex-direction: column; height: 100dvh; width: 100vw; }
        #canvas { position: absolute; top: 0; left: 0; width: 100% !important; height: calc(100% - 60px) !important; z-index: 1; }
        
        /* デザイン版のCSSをそのまま移植 */
        .main-ui-container {
            position: absolute; 
            right: 10px; 
            top: 120px; 
            bottom: 70px; 
            display: flex; 
            align-items: flex-start; 
            gap: 45px; 
            z-index: 20; 
            pointer-events: auto;
        }

        #info-overlay { display: flex; flex-direction: column; align-items: flex-end; text-align: right; gap: 10px; }
        #rpm_val { font-size: 13vh; font-weight: 900; line-height: 0.8; margin-top: 10px; text-shadow: 3px 3px 12px #000; }
        #display1 { font-size: 18vh; font-weight: 900; line-height: 0.9; color: var(--hrc-white); text-shadow: 4px 4px 15px #000; }
        #display { font-size: 4vh; color: #bbb; text-shadow: 1px 1px 6px #000; }

        .right-panels { display: flex; flex-direction: row; gap: 15px; height: 100%; align-items: flex-start; }
        #lap-panel { width: 175px; height: 100%; display: flex; flex-direction: column; overflow: hidden; border-top: 2px solid #333; }
        #lap { flex: 1; overflow-y: auto; scrollbar-width: none; }
        .lap-row { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.1); font-size: 18px; font-weight: 900; }
        .best-lap { color: var(--hrc-red); }

        .data-panel { display: flex; flex-direction: column; gap: 15px; width: 110px; }
        .data-box { display: flex; flex-direction: column; align-items: flex-end; }
        .label { font-size: 11px; color: var(--hrc-red); font-weight: bold; }
        .val { font-size: 40px; font-weight: 900; line-height: 0.9; }

        footer { 
            height: 55px; display: flex; gap: 4px; padding: 4px; background: #000; border-top: 1px solid #333; 
            z-index: 100; position: fixed; bottom: 0; left: 0; right: 0;
        }
        button { flex: 1; background: #1a1a1a; color: #fff; border: 1px solid #444; border-radius: 4px; font-size: 10px; font-weight: bold; cursor: pointer; }
        button.waiting { background: var(--hrc-orange) !important; color: #000 !important; }
        button.active { background: var(--hrc-red) !important; color: #fff !important; }
        #saveLogBtn { background: #28a745; display: none; }
    </style>
</head>
<body>

<div id="dashboard">
    <canvas id="canvas"></canvas>
    <div class="main-ui-container">
        <div id="info-overlay">
            <div id="rpm_val">0</div>
            <div id="display1">00:00.000</div>
            <div id="display">TOTAL 00:00.000</div>
        </div>
        <div class="right-panels">
            <div id="lap-panel"><div id="lap"></div></div>
            <div class="data-panel">
                <div class="data-box"><div class="label">SPEED</div><div class="val" id="speed_val">0</div></div>
                <div class="data-box"><div class="label">MAX</div><div class="val" id="max_speed_val" style="color: #FFA500;">0</div></div>
                <div class="data-box"><div class="label">TEMP</div><div class="val" id="temp_val">--</div></div>
            </div>
        </div>
    </div>
    <footer>
        <button id="usbGpsBtn">USB GPS</button>
        <button id="btConnect">BLE START</button>
        <button id="startBtn">TIMER</button>
        <button id="lapBtn">LAP/RESET</button>
        <button id="saveLogBtn">LOG SAVE</button>
        <button id="reloadBtn">RELOAD</button>
    </footer>
</div>

<script>
'use strict';

// --- 各種定数とログ用変数 ---
const SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
const PULSE_UUID = "f4deb353-a4cf-4ffb-badb-2a5f2e3bb630";
let currentRPM = 0, currentTemp = 0, device = null, nmeaBuffer = '', lastPos = null;
let LAP_LINE_P1 = { lat: 0, lon: 0 }, LAP_LINE_P2 = { lat: 0, lon: 0 };
let swState = 0, startTime = 0, lapStartTime = 0, lapRecords = [];
let lastUsbDataTime = 0, lastBleDataTime = 0, isGpsFixed = false;
let usbWaiting = false, bleWaiting = false, isFrozen = false;
let freezeDisplayTime = "", freezeStartTime = 0, previousSideOfLine = null, lastLapTime = 0;
let currentSpeedKmh = 0, maxSpeed = 0, sessionMaxSpeed = 0;
let trackLogs = [], currentLapLog = [];

const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');

// --- 曲線タコメーターの移植 ---
function drawTacho(rpm) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const w = canvas.width, h = canvas.height, segments = 75, active = Math.floor((rpm / 14000) * segments);
    const sX = 20, hY = 80, bY = h - 20, rad = bY - hY, curveEnd = 30;
    
    for (let i = 0; i <= segments; i++) {
        let x, y, ang, prog;
        if (i <= curveEnd) {
            prog = i / curveEnd; ang = Math.PI + (prog * (Math.PI / 2)); x = sX + rad + Math.cos(ang) * rad; y = hY + rad + Math.sin(ang) * rad;
        } else {
            prog = (i - curveEnd) / (segments - curveEnd); x = (sX + rad) + (prog * (w - 15 - (sX + rad))); y = hY; ang = 1.5 * Math.PI;
        }
        if (i % 10 === 0 || i === segments) {
            ctx.save(); ctx.fillStyle = i < active ? "#fff" : "#444"; ctx.font = "italic bold 22px Arial"; ctx.textAlign = "center";
            ctx.fillText(Math.round((i / segments) * 14), x + Math.cos(ang) * 45, y + Math.sin(ang) * 45); ctx.restore();
        }
        if (i < segments) {
            ctx.fillStyle = i < active ? (((i/segments)*14000) >= 12500 ? "#E4002B" : (((i/segments)*14000) >= 8000 ? "#004098" : "#FFFFFF")) : "#222";
            ctx.save(); ctx.translate(x, y); ctx.rotate(ang + Math.PI / 2); ctx.fillRect(-5, -23, 10, 46); ctx.restore();
        }
    }
    document.getElementById('rpm_val').textContent = Math.floor(rpm);
}

// --- ロギング・通信・タイマーロジック (統合) ---
async function startUsbGps() {
    try {
        device = await navigator.usb.requestDevice({ filters: [] });
        await device.open(); usbWaiting = true;
        if (device.configuration === null) await device.selectConfiguration(1);
        await device.claimInterface(parseInt(localStorage.getItem('usb_interface')) || 1);
        while (device) {
            const result = await device.transferIn(parseInt(localStorage.getItem('usb_endpoint')) || 2, 512);
            const lines = (nmeaBuffer + new TextDecoder().decode(result.data)).split(/\r?\n/);
            nmeaBuffer = lines.pop(); lines.forEach(parseNMEA);
        }
    } catch (e) { console.error(e); usbWaiting = false; }
}

async function ble() {
    try {
        const bleDevice = await navigator.bluetooth.requestDevice({ filters: [{ services: [SERVICE_UUID] }] });
        bleWaiting = true;
        const server = await bleDevice.gatt.connect();
        const service = await server.getPrimaryService(SERVICE_UUID);
        const pC = await service.getCharacteristic(PULSE_UUID);
        await pC.startNotifications();
        pC.oncharacteristicvaluechanged = (e) => {
            lastBleDataTime = Date.now();
            const data = e.target.value;
            currentRPM = (data.getUint16(0, true) * 60) / (parseInt(localStorage.getItem('pl1')) || 1);
            currentTemp = data.getUint8(2);
            document.getElementById('temp_val').textContent = currentTemp;
        };
        bleWaiting = false;
    } catch (e) { console.error(e); bleWaiting = false; }
}

function dmmToDec(dmm, dir) { 
    if(!dmm) return 0;
    const dot = dmm.indexOf('.'); 
    const d = parseInt(dmm.substring(0, dot-2)), m = parseFloat(dmm.substring(dot-2)); 
    let dec = d + (m/60); return (dir === 'S' || dir === 'W') ? -dec : dec; 
}

function parseNMEA(line) {
    const p = line.split(',');
    if (line.includes('RMC')) {
        lastUsbDataTime = Date.now();
        isGpsFixed = (p[2] === 'A');
        if (isGpsFixed) {
            currentSpeedKmh = Math.round(parseFloat(p[7]) * 1.852);
            document.getElementById('speed_val').textContent = currentSpeedKmh;
            if (currentSpeedKmh > maxSpeed) maxSpeed = currentSpeedKmh;
            if (maxSpeed > sessionMaxSpeed) sessionMaxSpeed = maxSpeed;
        }
    }
    if (line.includes('GGA') && p[6] !== '0') {
        const cur = { lat: dmmToDec(p[2], p[3]), lon: dmmToDec(p[4], p[5]), time: Date.now(), rpm: currentRPM, temp: currentTemp, speed: currentSpeedKmh };
        if (swState === 1) currentLapLog.push(cur);
        if (swState === 1 && LAP_LINE_P1.lat !== 0) {
            const side = (LAP_LINE_P2.lon - LAP_LINE_P1.lon) * (cur.lat - LAP_LINE_P1.lat) - (LAP_LINE_P2.lat - LAP_LINE_P1.lat) * (cur.lon - LAP_LINE_P1.lon);
            if (lastPos && previousSideOfLine !== null && ((previousSideOfLine > 0 && side < 0) || (previousSideOfLine < 0 && side > 0))) {
                if (Date.now() - lastLapTime >= (parseFloat(localStorage.getItem('lapCoolDownTime')) || 15000)) processLap(Date.now(), true);
            }
            previousSideOfLine = side;
        }
        lastPos = cur;
    }
}

function processLap(exactTime, useFreeze) {
    const lapTime = exactTime - (lapStartTime || startTime);
    lapRecords.unshift(lapTime);
    trackLogs.push([...currentLapLog]);
    currentLapLog = [];
    const finishedLapMaxSpeed = maxSpeed; maxSpeed = 0; 
    lapStartTime = exactTime; lastLapTime = exactTime;
    
    const d = document.getElementById('lap'); d.innerHTML = "";
    const best = Math.min(...lapRecords);
    lapRecords.forEach((t, i) => {
        const r = document.createElement('div'); r.className = `lap-row ${t === best ? 'best-lap' : ''}`;
        r.innerHTML = `<span>L${lapRecords.length-i}</span><span>${timeFormat(t)}</span>`; d.appendChild(r);
    });
    if (useFreeze) { 
        isFrozen = true; freezeDisplayTime = timeFormat(lapTime); 
        document.getElementById('max_speed_val').textContent = finishedLapMaxSpeed;
        document.getElementById('max_speed_val').style.color = (finishedLapMaxSpeed >= sessionMaxSpeed) ? "#E4002B" : "#ffffff";
        freezeStartTime = Date.now(); 
    }
}

function exportGPX() {
    if (trackLogs.length === 0 && currentLapLog.length === 0) return;
    const all = [...trackLogs, currentLapLog];
    let gpx = `<?xml version="1.0" encoding="UTF-8"?><gpx version="1.1" creator="KLAP_DEGI" xmlns="http://www.topografix.com/GPX/1/1" xmlns:gpxtpx="http://www.garmin.com/xmlschemas/TrackPointExtension/v1">`;
    all.forEach((lap, i) => {
        if (lap.length === 0) return;
        gpx += `\n<trk><name>Lap ${i+1}</name><trkseg>`;
        lap.forEach(p => { 
            gpx += `\n  <trkpt lat="${p.lat}" lon="${p.lon}"><time>${new Date(p.time).toISOString()}</time><extensions><gpxtpx:TrackPointExtension><gpxtpx:hr>${Math.round(p.rpm)}</gpxtpx:hr><gpxtpx:atemp>${p.temp}</gpxtpx:atemp></gpxtpx:TrackPointExtension><speed>${(p.speed / 3.6).toFixed(2)}</speed></extensions></trkpt>`; 
        });
        gpx += `\n</trkseg></trk>`;
    });
    gpx += `\n</gpx>`;
    const blob = new Blob([gpx], { type: 'application/gpx+xml' });
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `RaceLog_${Date.now()}.gpx`; a.click();
}

function timeFormat(ms) { 
    let m = Math.floor(ms/60000), s = Math.floor((ms%60000)/1000), mss = Math.floor(ms%1000); 
    return `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}.${mss.toString().padStart(3,'0')}`; 
}

function tick() { 
    if (swState !== 1) return;
    const now = Date.now();
    document.getElementById('display').textContent = "TOTAL " + timeFormat(now - startTime);
    if (isFrozen) {
        document.getElementById('display1').textContent = freezeDisplayTime;
        if (now - freezeStartTime > 15000) isFrozen = false;
    } else {
        document.getElementById('display1').textContent = timeFormat(now - lapStartTime);
        document.getElementById('max_speed_val').textContent = maxSpeed;
    }
    requestAnimationFrame(tick);
}

// 通信状態監視
setInterval(() => {
    const now = Date.now();
    const uBtn = document.getElementById('usbGpsBtn'), bBtn = document.getElementById('btConnect');
    uBtn.className = (now - lastUsbDataTime < 1500 && isGpsFixed) ? 'active' : (usbWaiting ? 'waiting' : '');
    bBtn.className = (now - lastBleDataTime < 1500) ? 'active' : (bleWaiting ? 'waiting' : '');
}, 1000);

document.getElementById('usbGpsBtn').onclick = startUsbGps;
document.getElementById('btConnect').onclick = ble;
document.getElementById('saveLogBtn').onclick = exportGPX;
document.getElementById('startBtn').onclick = () => {
    if (swState !== 1) {
        swState = 1; startTime = Date.now(); lapStartTime = startTime; trackLogs = []; currentLapLog = [];
        document.getElementById('startBtn').classList.add('active');
        document.getElementById('saveLogBtn').style.display = 'none';
        tick();
    } else {
        swState = 2; document.getElementById('startBtn').classList.remove('active');
        document.getElementById('saveLogBtn').style.display = 'block';
    }
};
document.getElementById('lapBtn').onclick = () => { 
    if(swState === 1) processLap(Date.now(), false); 
    else { swState = 0; lapRecords = []; trackLogs = []; currentLapLog = []; maxSpeed = 0; sessionMaxSpeed = 0;
        document.getElementById('max_speed_val').textContent = "0";
        document.getElementById('lap').innerHTML = ""; document.getElementById('display1').textContent = "00:00.000"; document.getElementById('display').textContent = "TOTAL 00:00.000";
    }
};
document.getElementById('reloadBtn').onclick = () => location.reload();

window.onresize = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight - 60; };
window.onload = () => { 
    window.dispatchEvent(new Event('resize')); 
    const p1Lat = localStorage.getItem('startLineP1Lat');
    if (p1Lat) {
        LAP_LINE_P1 = { lat: parseFloat(p1Lat), lon: parseFloat(localStorage.getItem('startLineP1Lon')) };
        LAP_LINE_P2 = { lat: parseFloat(localStorage.getItem('startLineP2Lat')), lon: parseFloat(localStorage.getItem('startLineP2Lon')) };
    }
    (function render(){ drawTacho(currentRPM); requestAnimationFrame(render); })();
};
</script>
</body>
</html>
